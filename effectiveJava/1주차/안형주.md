# 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라.

1. 클래스의 인스턴스를 얻는 전통적인 수단은 public constructor
2. 정적 팩터리 메서드(클래스의 인스턴스를 반환하는 단순한 정적 메서드)를 제공할 수 있다.

---

> 참고) 정적 팩터리 메서드와 디자인 패턴에서의 팩터리 메서드 패턴은 다르다.

[https://johngrib.github.io/wiki/factory-method-pattern/](https://johngrib.github.io/wiki/factory-method-pattern/)

## 1.1. 장단점

- 장점
    1. **이름을 가질 수 있다.**

       → 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못한다.
       반면 정적 팩터리 메서드는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.

       → 하나의 시그니처로는 생성자를 하나만 만들 수 있다. overloading을 사용하면 회피할 수 있지만, 사용하는 개발자가 실수할 가능성이 생긴다. 반면 정적 팩터리 메서드는 각각의 차이를 잘 나타내는 이름만 지어주면 된다.

    2. **호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.**

       → 인스턴스를 미리 만들어 놓거나(static final field or private static class) 새로 생성한 인스턴스를 캐싱하여 재활용(개발자가 로직에서 재사용)하는 식으로 불필요한 객체 생성을 피할 수 있다.

       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/15398f62-aa69-4330-ad8f-9f2aaa55ec3b/Untitled.png)

       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6067ffc6-c9bb-4d20-82dd-a7aaec0c10f6/Untitled.png)

       → 생성비용이 크거나 자주 사용하는 객체라면 성능을 상당히 끌어올려 준다.

       > 참고) 플라이웨이트 패턴도 이와 비슷한 기법이다.

       [https://readystory.tistory.com/137](https://readystory.tistory.com/137)

       → 반복 요청에 같은 객체를 반환하는 식으로 언제 어느 인스턴스가 살아 있게 할지를 통제하는 클래스를 인스턴스 통제 클래스라고 한다. 인스턴스를 통제하면 클래스를 싱글턴, 인스턴스화 불가로 만들 수도 있다. 또한 불변 값 클래스에서 a == b일때만 a.equals(b)가 성립됨을 보장할 수 있다. 따라서 인스턴스 통제는 플라이웨이트 패턴의 근간이되며, 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다.

    3. **반환타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**

       → 반환할 객체를 자유롭게 선택할 수 있는 유연성을 제공한다. 생성할 때도 리스코프 치환원칙을 지킬 수 있다.

       → 대표적인 활용 예제는 Collections이다. API가 작아진 것은 물론 개념적인 무게, 즉 프로그래머가 API를 사용하기 위해 익혀야 하는 개념의 수와 난이도도 낮췄다. 예를들어 Collections.sort()를 사용할 때 어떤 구현 클래스가 내부적으로 어떻게 동작하는지 알 필요없이, 컬렉션이 정렬된다는 것만 알고 사용할 수 있다.

    4. **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**

       → EnumSet 클래스의 경우 public 생성자 없이 오직 정적 팩터리만 제공하는데, 내부적으로 64개 원소 이하(대다수에 해당하는)인 경우 RegularEnumSet의 인스턴스를, 65개 이상이면 JumboEnumSet의 인스턴스를 반환한다. 클라이언트는 이를 몰라도 되고 알 필요도 없다.
       `EnumSet<E> enumSet = EnumSet.noneOf(Class<E> elementType)로 사용하면 된다.`

       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18d6d9e0-7bc8-4038-b304-4c286ff2c620/Untitled.png)

       따라서 64개 이하의 원소에서 RegularEnumSet을 사용할 이점이 없어진다면 다음 릴리즈때 이를 삭제해도 아무 문제가 없다. 비슷하게 다음, 그 다음에도 성능을 개선한 새로운 클래스를 추가해도 된다. EnumSet의 하위 클래스이기만 하다면.

    5. **정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**

       → 이는 서비스 제공자 프레임워크를 만드는 근간이 된다.

       → 제공자(provider)는 서비스의 구현체다. 그리고 이 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제하여, 클라이언트를 구현체로부터 분리해준다.

       → 서비스 제공자 프레임워크는 3개의 핵심 컴포넌트 + (4번째 컴포넌트)로 이뤄진다.
        1.  서비스 인터페이스 → 구현체의 동작을 정의 `Connection`
        2. 제공자 등록 API →  제공자가 구현체를 등록할 때 사용 `DriverManager.registerDriver()`
        3. 서비스 접근 API →  클라이언트가 서비스의 인터페이스를 얻을 때 사용 `DriverManager.getConnection()`
        4. 서비스 제공자 인터페이스 → 서비스 인터페이스의 인스턴스를 제공 `Driver`
           이 서비스 접근 API가 바로 서비스 제공자 프레임워크의 근간이라고 한 '유연한 정적 팩터리'의 실체다.

       jdbc Connection 실제 사용하지 않아서 와닿지 않음. 뒤에 DI(아이템5)에서 다시 보자.

- 단점
    1. **상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.**

       → 상속보다 컴포지션을 사용(아이템 18)하도록 유도하고 불변 타입(아이템 17)로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 볼 수 있다.

    1. **정적 팩터리 메서드는 프로그래머가 찾기 어렵다.**

       → 널리 알려진 규약을 따라 짓는 식으로 문제를 완화해줄 수 있다.

       → 흔히 사용하는 명명 방식(ex. from, of, valueOf, instance, getInstance, create, newInstance, getType, newType, type)을 사용하자.

## 1.2. 핵심 정리

public 생성자와 정적 팩터리 메서드는 각자의 쓰임새가 있다. 장단점을 이해하고 사용하자. 하지만 정적 팩터리 메서드 사용이 유리한 경우가 많다.

- public 생성자 → 말 그대로 클래스 인스턴스의 생성 의미만 가질 때 사용하자.

---

# 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라.

정적 팩터리와 생성자 모두 선택적 매개변수가 많을 경우 대응에 어려움이 있다. 이럴경우 빌더 패턴을 고려해보자.

## 2.1. 해결 방법

- 세가지 방법
    1. 점층적 생성자 패턴

       과거에는 이를 해결하기 위해서 점층적 생성자 패턴(필수 매개변수만 받는 생성자, 필수 + 선택1 매개변수를 받는 생성자 + ...)을 사용했다.

       → 장점: 기본적이고 만들기 쉽다

       → 단점: 매개변수가 많아질 수록 클라이언트 코드를 작성(실수로 순서를 바꾼다던가..)하거나 읽기 어렵다.

    2. 자바빈즈 패턴

       점층적 생성자 패턴의 단점을 보완할 수 있는 자바빈즈 패턴이 있다. default 생성자로 객체를 만든 후 setter로 원하는 매개변수의 값을 설정하는 방식이다.

       → 장점: 점층적 생성자 패턴의 단점을 보완 가능

       → 단점: 객체 하나를 만들기 위해서 메서드를 여러개 호출해야하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진다. 즉, 불변 클래스로 만들 수 없다.

    3. freeze

       freeze() 메서드를 만들어 생성이 끝난 객체를 수동으로 freeze()하고 그 전에는 객체를 사용할 수 없도록 한다. (isFreeze() 같은 메서드를 콜할듯?)

       → 장점: 자바빈즈 패턴의 단점을 보완할 수 있다.

       → 단점: freeze인지 프로그래머가 수동으로 확인해야하고 컴파일러 단에서 오류를 잡아낼 수 없다. 따라서 런타임 오류에 취약하다.

    4. 빌더 패턴

       빌더 패턴을 사용하자(롬복의 @Builder를 사용하자) 다 알테니 넘어가자

       → 장점: 위 방법들의 단점을 모두 보완할 수 있다. 메서드 체이닝을 통해 읽고 쓰기쉬운 코드를 작성할 수 있다. 유연하다.

       → 단점: 만들기 어렵다. 빌더를 만들기 위한 생성비용도 조금 있다. 매개변수가 4개 이상은 되어야 값어치를 한다.

- 참고
    - 불변(immutable or immutability)는 어떠한 변경도 허용하지 않는다는 뜻, 변경을 허용하는 가변(mutable) 객체와 반대
    - 불변식(invariant)은 프로그램이 실행되는 동안, 혹은 정해진 기간 동안 반드시 만족해야 하는 조건을 말한다. 즉, 변경을 허용하나 주어진 조건 내에서 허용

## 2.2. 핵심 정리

생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면(4개 이상) 빌더 패턴을 선택하는게 더 낫다.  게다가 API는 시간이 지날수록 매개변수가 많아질 확률이 높다. 따라서 생성자와 정적 팩터리에서 많아지면 빌더로 바꾸는 것보다 애초에 빌더로 시작하는 편이 나을 때가 많다. → 팀 컨벤션에 따르자
결론. 빌더는 읽고 쓰기가 간결하고, 안전하다.

---

# 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라.

싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다. 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트를 예로 들 수 있다. 간결하고 추가적인 노력 없이 싱글턴으로 만드는 가장 좋은 방법은 Enum으로 만드는 것이다. enum을 사용할 수 없는 경우 매우 복잡한 추가 로직이 들어가야하는데

싱글턴 자체가 **안티패턴**이다. 가볍게 읽고 넘어간다음 꼭 필요하다고 생각될 때 다시 찾아보자.

---

# 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라.

주의) 정적 메서드와 정적 필드만을 담은 클래스는 객체 지향적으로 사고하지 않을 때 남용되는 방식이다.

하지만 분명 나름의 쓰임새가 있고 필요할 때가 있다 → 일반적으로 util 클래스

이는 인스턴스로 만들어 쓰려고 설계한 게 아니다. 하지만 생성자를 명시하지 않으면 컴파일러가 자동으로 default constructor를 만든다. 사용자가 이를 구분할 수 없으므로 실수할 여지가 있다.

## 4.1. 방법

- 추상 클래스
    - 장점: 쉽게 인스턴스화를 막을 수 있다.
    - 단점: 하위 클래스를 만들어서 우회해서 인스턴스화 가능, 상속해서 쓰라는 뜻으로 오해 가능

- final 클래스 + private 생성자
    - 장점: 상속을 방지할 수 있다. 원천적으로 인스턴스화를 막을 수 있다.
    - 단점: 생성자가 있는데 호출 할 수 없으므로 직관적이지 않다. 귀찮다.

## 4.2. 결론

일반적으로 final + private 생성자(= 롬복의 @UtilityClass)를 사용하는 것을 권장하나, abstract class를 사용할 수도 있다. 팀 컨벤션에 맞게 사용하면 된다.

---

# 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.

인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식.

## 5.1. 장단점

- 장점
    - 유연성과 테스트 용이성을 높여준다. → 자원이 몇 개든 자원의 의존 관계가 어떻든 상관없이 잘 작동한다
    - 불변을 보장한다. → 여러 클라이언트가 안심하고 공유 가능
    - 생성자, 정적 팩터리, 빌더 모두에 똑같이 응용 가능
- 단점
    - 의존성이 수 천 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들기도 한다. → 스프링같은 의존 객체 주입 프레임워크를 사용하면 해소 가능(but, 순환 의존성은 조심하자)

## 5.2. 핵심 정리

클래스 생성에 필요한 자원을 DI를 통해  받아오자. 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다. 즉, 객체 지향적이다.

---

# 아이템 6. 불필요한 객체 생성을 피하라.

똑같은 기능의 객체를 매번 생성하지 말고 재사용하는것이 더 빠르고 세련되다.

## 6.1. 피해야하는 예제

- 일반적으로 불필요한지 아닌지에 대해서 경험적으로 알 수는 있지만, 정확히 알기는 어렵다. → 성능 이슈가 생기면 이 아이템도 한 번 생각해보자.
1. `new String("bikini")`

   → 실행될 때 마다 새로운 String 인스턴스를 만든다.

   → `= "bikini"`를 사용하면 똑같은 비키니 문자열은 모두 재사용이 보장된다.

2. `new Boolean(String)`

   → 앞에서 봤듯이 `valueOf()` 정적 팩터리를 사용해서 재사용하는 것이 좋다.

   → 해당 생성자는 자바9부터 deprecated

3. 정규 표현식

   → `String.matches` 메서드에서 내부적으로 정규표현식용 Pattern 인스턴스를 한 번 사용하고 GC 대상으로 버려진다.

   → `private static final Patten ROMAN = Pattern.compile("~~");` 로 직접 생성해 캐싱해두어 재사용 하자.

   → 추가로 매직넘버를 필드로 끄집어내 이름을 지어주어 코드의 의미가 훨씬 잘 드러난다.

4. 오토 박싱

   → 오토 박싱은 기본 타입(원시 타입)과 박싱 타입(래퍼 클래스)의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.

   → 래퍼 클래스보다는 원시 타입을 사용하고, 의도치 않은 오토 박싱이 숨어들지 않도록 주의하자.

   → 이후에 나오겠지만, 오토 박싱을 사용하지 않아도 되도록 함수(람다와 스트림)를 재사용하자.

## 6.2. 오해

- **"객체 생성은 비싸니 피해야한다" 가 아니다.** 최근에는 프로그램의 명확성, 간결성, 기능을 위해 객체를 추가 생성, 삭제하는 것이라면 성능적인 측면보다 오히려 더 장점이 많다는 것으로 결론이 났다.

  → 즉, "**기존 객체를 재사용해야한다면 새로운 객체를 만들지 마라**"라는 뜻이다.

---

# 아이템 7. 다 쓴 객체 참조를 해제하라

자바를 사용하면 GC가 다 해주니 메모리 관리에 신경을 쓰지 않아도 된다고 오해할 수 있는데, 절대 사실이 아니다.

- **자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다.**
- 캐시 역시 메모리 누수를 일으키는 주범이다. → [WeakHashMap](http://blog.breakingthat.com/2018/08/26/java-collection-map-weakhashmap/)을 사용하자

## 7.1. 핵심 정리

- 메모리 누수는 찾기 어려우므로 예방법을 익혀두는 것이 매우 중요하다.
- (개인적으로)라이브러리나 프레임워크를 만들지 않는 웹 개발자(우리같은)가 자기 메모리를 직접 관리하는 클래스를 만들 일이 없을듯 하다.

---

# 아이템 8. finalizer와 cleaner 사용을 피하라.

finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.

cleaner는 finalizer보단 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.

나름의 쓰임새가 있긴하지만, 기본적으로 두 가지는 쓰지 말아야 한다.

## 8.1. 단점

- finalizer와 cleaner는 즉시 수행된다는 보장이 없다. 즉, 제때 실행되어야 하는 작업은 절대로 할 수 없다.

  → 전적으로 가비지 컬렉터 알고리즘에 달렸다.

- 클래스에 finalizer를 달아두면 그 인스턴스의 자원 회수가 멋대로 지연될 수 있다.
- 자바 언어 명세는 finalizer나 cleaner의 수행 시점뿐 아니라 수행 여부 조차 보장하지 않는다.

  → 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다.

- finalizer 동작중 발생한 예외는 무시되며 경고조차 출력하지 않는다.
- finalizer와 cleaner는 심각한 성능 문제도 동반한다.
- 뒤에 더 있는데 이쯤되면 읽어보기만 하고 그냥 사용하지 말자.

---

# 아이템 9. try-finally보다는 try-with-resources를 사용하라.

자바 라이브러리에서 close 메서드를 호출해 직접 닫아줘야하는 자원(ex. InputStream, OutputStream, java.sql.Connection 등)은 try-with-resources를 사용하자.

## 9.1. 장단점

- 장점
    - 짧고 읽기 수월하고 분명해진다.(가독성이 좋아진다.)
    - 만들어지는 예외 정보가 유용해진다.
    - 정확하고 쉽게 자원을 회수할 수 있다.
- 단점
    - AutoCloseable을 반드시 구현해야해서 귀찮다(?)

## 9.2. 핵심 정리

회수해야하는 자원을 다룰때는 **무조건 try-with-resources**를 사용하자.