# 3장. 모든 객체의 공통 메서드

- Object에서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는 모두 재정의(overriding)을 염두에 두고 설계된 것이다. 따라서 모든 클래스는 이 메서드들을 일반 규약에 맞게 재정의해야 한다.
- 위 메서드를 잘못 구현하면 이 규약을 준수한다고 가정하는 클래스들(HashMap, HashSet 등)이 오동작 할 수 있다.
- 이번 장에서는 위 메서드들을 언제 어떻게 재정의해야하는지를 다룬다.(+ Comparable.compareTo는 성격이 비슷하여 함께 다룬다.)

---

## 3.1. [아이템 10] equals는 일반 규약을 지켜 재정의하라.

equals()를 재정의하는 것은 오용할 경우 의도치 않은 결과를 불러온다. 이를 회피하기 위한 가장 쉬운 방법은 아예 재정의를 하지 않는 것이다.

### 3.1.1. 재정의를 하지 않아야 하는 경우

- **각 인스턴스가 본질적으로 고유하다.**

  → 값을 표현하는 게 아닌 동작하는 개채를 표현하는 클래스.

  → ex) Thread는 값을 표현하는 객체가 아니므로 근본적으로 모든 스레드 인스턴스들은`thread1.equals(thread2) == false` 여야 한다.


- **인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없다.**

  → ex) Pattern의 두 인스턴스가 같은 정규표현식을 나타내면 `p1.equals(p2) == true` 로 논리적 동치성을 검사하도록 할 수 있지만, 이 방식을 원하지 않거나 필요하지 않다고 판단한다면 기본적인 Object.equals만으로 해결된다.(실제로 찾아본 결과 Pattern은 equals를 재정의하고 있지 않다.)


- **상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.**

  → ex) 대부분의 Set 구현체는 AbstractSet이 구현한 equals를 상속받아 쓴다.


- **클래스가 private이거나 pakage-private이고 equals 메서드를 호출할 일이 없다.**

  → 위 경우는 클래스 접근이 제한적이기 때문에 equals메서드를 호출할 일이 있는지 없는지를 쉽게 판단할 수 있다.

  → 추가적으로 실수로라도 호출되는 것을 막고 싶으면 equals 호출시 `throw new AssertionError()`로 명시해주자.


### 3.1.2. 재정의를 해야하는 경우

- **객체의 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때**

  → 주로 값 클래스(ex. Integer, String 등 값을 표현하는 클래스)

  → 값 클래스이지만 인스턴스 통제 클래스라면 재정의할 필요 없다.(feat. Enum)


### 3.1.3. equals 메서드를 재정의할 때 필수 규약

- equals 메서드는 동치관계(equivalence relation)을 구현하며, 다음을 만족한다.
    - **반사성(reflexivity)**: null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true다.
    - **대칭성(symmetry)**: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
    - **추이성(transitivity)**: null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true고 y.equals(z)가 true면 x.equals(z)도 true다.
    - **일관성(consistency)**: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복 호출해도 항상 true나 false를 반환한다.
    - **null-아님**: null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 항상 false다.


### 3.1.4. 좋은 equals 메서드를 구현하는 방법

1. `==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
2. `instanceof` 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자기 자신의 대응되는 '핵심'필드들이 모두 일치하는지 하나씩 검사한다.
    - float와 double을 제외한 기본 타입 필드는 `==`로 비교한다.
        - float와 double은 각각 정적 메서드인  `Float.compare(float, float)`, `Double.compare(double, double)` 로 비교한다.(부동소수를 다뤄야 하기 때문)
        - 주의! `equals`로 대신 사용할 수는 있지만, 오토박싱을 수반할 수 있어 성능상 좋지 않다.
    - 참조 타입 필드는 각각의 equals 메서드로 비교한다.
    - 배열 필드는 원소 각각을 위 지침대로 비교하고, 만약 모든 원소가 핵심 필드라면 `Arrays.equals` 메서드들 중 하나를 사용하자.
    - null도 정상 값으로 취급하는 참조 타입 필드(nullable 허용)는 정적 메서드인 `Objects.equals(Object, Object)` 로 비교해 NPE 발생을 예방하자.
    - 비교하기가 아주 복잡한 필드를 가진 클래스는 필드의 표준형(canonical form)을 저장해둔 후 표준형끼리 비교하면 훨씬 경제적이다. 특히 불변 클래스에 제격이다. 가변 객체라면 값이 바뀔 때마다 표준형을 최신 상태로 갱신해줘야 한다.

      > **표준형이란?**
      java.math.BigDecimal의 경우를 예로 들어 보자. 다음과 같이
      BigDecimal 인스턴스를생성해보자.

      `BigDecimal n = new BigDecimal ( "-12345.6789" )`
      이때, BigDecimal 내부에서는 -12345.6789라는 수를 어떻게 저장하고
      있을까?
      BigDecimal의 소스를 보면 다음과 같은 필드를 정의하고 있다.
      `private BigInteger intVal;
      private int scale = 0;`

      BigDecimal은 -12345.6789라는 숫자를 그대로 보관하는 것이 아니라, 이수의 숫자부분(-123456789)은 BigInteger intValue 필드에, 10의제곱수부분(-4)은 int scale 필드에 보관한다.
      -12345.6789를 -123456789와 -4로 나누어 -123456789x10-4로 표현하는 것이 10진수를 표현하는 표준형식(canonical form)이다.
      이렇게 표준형식으로 저장하면 어떤 숫자라도 정확하게 표현할 수 있다.

      참조) [https://download.oracle.com/global/kr/magazine/23fall_tech2.pdf](https://download.oracle.com/global/kr/magazine/23fall_tech2.pdf)
      >
    - 어떤 필드를 먼저 비교하느냐가 equals의 성능을 좌우하기도 한다. 다를 가능성이 크거나(= cardinality가 낮은) 비교하는 비용이 싼 필드를 먼저 비교하자.

- equals를 다 구현한 후 대칭적인가? 추이성이 있는가? 일관적인가? 를 유닛 테스트를 작성해 돌려보자.
- equals를 재정의할 땐 hashcode도 반드시 재정의 하자(아이템 11)
- 너무 복잡하게 해결하려 들지 말자.
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.
- **tip!!** 위의 사항을 알고 intellij의 method generate 기능을 이용하여 생성하면 위의 좋은 equals를 자동으로 만들어준다.(AutoValue를 쓰는 건 본적이없음)

### 3.1.4. 핵심 정리

- 꼭 필요한 경우가 아니라면 equals를 재정의하지 말자.
- 필요한 경우에는 다섯 가지 규약을 확실히 지켜가며 ide의 method generate 기능을 사용하여 재정의하자.

---

## 3.2. [아이템 11] equals를 재정의하려거든 hashCode도 재정의하라.

equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게되어 문제가 발생한다.

> **Object 명세에서 발췌한 hashCode관련 규약**
>
> - equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관 없다.
> - equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야한다.
> - equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

hashCode 재정의를 잘못했을 때 크게 문제가 되는 조항은 두번째다. 즉, 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.

### 3.2.1. 올바른 hashCode를 작성하는 방법

1. int 변수 result를 선언한 후 값 c로 초기화한다. 이때 c는 해당 객체의 첫번째 핵심 필드를 단계 2.a 방식으로 계산한 해시코드다(여기서 핵심 필드란 equals 비교에 사용되는 필드를 말한다. 아이템 10 참조)
2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다.
    1. 해당 필드의 해시코드 c를 계산한다.
        1. 기본 타입 필드라면, `Type.hashCode(f)`를 수행한다. 여기서 Type은 해당 기본 타입의 박싱 클래스다.
        2. 참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals를 재귀적으로 호출해 비교한다면, 이 필드의  hashCode를 재귀적으로 호출한다. 계산이 더 복잡해질 것 같으면, 이 필드의 표준형을 만들어 그 표준형의 hashCode를 호출한다. 필드 값이 null이라면 0을 사용한다.(다른 상수도 괜찮지만 전통적으로 0을 사용한다.)
        3. 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 단계 2.b방식으로 갱신한다. 배열에 핵심 원소가 하나도 없다면 단순히 상수(0을 추천)를 사용한다. 모든 원소가 핵심 원소라면 `Arrays.hashCode`를 사용한다.
    2. 단계 2.a에서 계산한 해시코드 c로 result를 갱신한다. 코드로는 다음과 같다.
       `result = 31 * result + c;`
3. result를 반환한다.
4. hashCode가 동치인 인스턴스에 대해 똑같은 해시코드를 반환하는지 확인한다.(feat. 단위 테스트)
5. 파생 필드는 해시코드 계산에서 제외한다. 즉, 다른 필드로부터 계산해 낼 수 있는 필드는 모두 무시한다. 또한, equals 비교에 사용되지 않은 필드는 '반드시' 제외해야 한다.
6. 단계 2.b에서 31 * result는 필드를 곱하는 순서에 따라 result 값이 달라지게 한다. 그 결과 클래스에 비슷한 필드가 여러 개일 때 해시 효과를 크게 높여준다. 숫자가 31인 이유는 홀수면서 소수이기 때문이다.
7. 해시 충돌이 더 적은 방법을 꼭 써야 한다면 구아바의 com.google.common.hash.Hashing을 참고하자.
8. 클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기 보다는 캐싱하는 방식을 고려하자. 이 타입의 객체가 주로 해시의 키로 사용될 것 같다면 인스턴스가 만들어질 때 해시코드를 계산해둬야 한다. 해시의 키로 사용되지 않는 경우라면 hashCode가 처음 불릴 때 계산하는 지연 초기화 전략도 좋다. 단, 지연 초기화할때는 스레드 안전하게 만들도록 신경 써야 한다.(아이템 83)
9. 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안된다.
10. hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산방식을 바꿀 수도 있다.

### 3.2.2. 핵심 정리

- equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다. 그렇지 않으면 프로그램이 제대로 동작하지 않을 수 있다.
- 재정의한 hashCode는 Object의 API 문서에 기술된 일반 규약을 따라야하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다.
- AutoValue 프레임워크나 좋은 IDE를 사용해 자동으로 만들어주는 좋은 equals나 hashCode를 사용하자.

---

## 3.3. [아이템 12] toString을 항상 재정의하라.

toString의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환해야 한다.

또한, "모든 하위 클래스에서 이 메서드를 재정의하라"고 한다.

toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.

### 3.3.1. 올바른 toString 재정의 방법

- 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는게 좋다. 하지만 객체가 거대하거나 상태가 문자열로 표현하기 어렵다면 요약 정보를 담아야한다. **이상적으로는 스스로를 완벽히 설명하는 문자열이어야 한다.**
- 반환값의 포맷을 문서화할지 정해야 한다.
    - 포맷 문서화 O
        - 전화번호나 향렬 같은 값 클래스라면 문서화하기를 권한다. 포멧을 명시하면 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다. 따라서 그 값 그대로 입출력에 사용하거나 CSV 파일처럼 사람이 읽을 수 있는 데이터 객체로 저장할 수도 있다.
        - 단점으로, 포맷을 한 번 명시하면 (그 클래스가 많이 쓰인다면) 평생 그 포멧에 얽매이게 된다. 만약 향후 릴리스에서 포맷을 바꾼다면 이를 사용하던 코드들과 데이터들은 엉망이 될 것이고, 유지보수나 확장에 큰 어려움이 생길 것이다.
    - 포맷 문서화 X
        - 포맷을 명시하지 않는 다면 향후 릴리스에서 정보를 더 넣거나 포맷을 개선할 수 있는 유연성을 얻게된다.
    - 포맷을 명시하는 아니든 의도는 명확히 밝혀야 한다.
- 포맷 명시 여부와 상관없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.

### 3.3.2 핵심 정리

- 모든 구체 클래스에서 Object의 toString을 재정의하자. 상위 클래스에서 이미 알맞게 재정의한 경우는 예외다.
- toString을 올바르게 재정의한 클래스는 사용하기도 좋고 디버깅하기도 쉽다.
- toString은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.

---

## 3.4. [아이템 13] clone 재정의는 주의해서 진행하라.

Cloneable은 문제가 너무 많은데 비해 사용할 일이 많지 않기 때문에 정리를 생략한다.

기본적으로 복제 기능에서는 '변환 생성자'와 '변환 팩터리'를 사용하고, 이미 Cloneable로 구현된 클래스를 상속받는 구현체를 만드는 경우에 다시 찾아보면서 구현하자.

### 3.4.1 핵심정리

- Cloneable이 몰고 온 모든 문제를 되짚어봤을 때, 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안 되며, 새로운 클래스도 이를 구현해서는 안 된다.
- final class라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 한다(아이템 67)
- 기본 원칙은 복제 기능은 '변환 생성자'와 '변환 팩터리'를 이용해서 구현하는 것이 베스트다.
- 단, 배열만은 clone 메서드 방식이 가장 깔끔하다.

---

## 3.5. [아이템 14] Comparable을 구현할지 고려하라.

Comparable 인터페이스의 유일무이한 메서드인 compareTo를 알아보자.

compareTo는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다. Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서(natural order)가 있음을 뜻한다.

그래서 Comparable을 구현한 객체들의 배열은 다음처럼 손쉽게 정렬할 수 있다.
`Arrays.sort(a);`

검색, 극단값 계산, 자동 정렬되는 컬렉션 관리도 쉽게 할 수 있다. 사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거 타입(아이템 34)이 Comparable을 구현했다. 알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자.

### 3.5.1. compareTo 메서드의 일반 규약

> 이 객체와 주어진 객체의 순서를 비교한다. 이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환한다. 이 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다.
>

compareTo 메서드로 수행하는 동치성 검사도 equals 규약과 똑같이 반사성, 대칭성, 추이성을 충족해야 한다.

### 3.5.2 핵심 정리

- 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야한다.
- compareTo 메서드에서 필드의 값을 비교할 때 `< 와 >` 연산자 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.