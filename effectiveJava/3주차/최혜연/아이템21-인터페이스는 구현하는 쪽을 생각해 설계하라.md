# 4장. 클래스와 인터페이스 - GOAL

> 추상화의 기본 단위인 클래스와 인터페이스는 자바의 심장이다.  
> 클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만들어보자

## 아이템21. 인터페이스는 구현하는 쪽을 생각해 설계하라

자바 8전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다.  
인터페이스에 메서드를 추가하면 보통은 컴파일 오류가 나는데, 추가된 메서드가 기존 구현체에 존재할 가능성이 낮기 때문이다.  
자바 8에 와서, 이를 해결할 수 있는 디폴트 메서드가 등장했지만 위험이 완전히 사라진 것은 아니다.

## 디폴트 메서드

디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. 하지만 모든 기존 구현체들과 매끄럽게 연동되리라는 보장은 없다. 디폴트 메서드는 구현 클래스에 대해 아무것도 모른 채 합의없이 무작정 '삽입' 될 뿐이다.  
자바 8 에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다. 주로 람다를 활용하기 위해서다. 자바 라이브러리의 디폴트 메서드는 코드 품질이 높고, 범용적이라 대부분 상황에서 잘 작동한다.

## 디폴트 메서드의 단점

### 1\. 생각할 수 있는 모든 상황에서 불변식을 해치지 않는, 디폴트 메서드를 작성하기는 어렵다.

```java
    default boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator<E> each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
```

아파치 `SynchronizedCollection` 는 모든 메서드에 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스이다. 이 책을 쓰는 시점엔 `SynchronizedCollection`는 `removeIf`를 재정의 하지 않고 있다. 그래서 이 클래스를 자바8과 함께 사용한다면(removeIf의 디폴트 구현을 물려받게 된다면), 자신이 한 약속을 더이상 지키지 못하게 된다.  
다시 말해 모든 메서드 호출을 알아서 동기화해주지 못한다. removeIf 구현은 동기화에 관해 모르므로 락 객체 사용이 불가하다.`SynchronizedCollection`를 여러 스레드가 공유하는 환경에서 한 스레드가 `removeIf`를 호출하면 예기치 못한 결과로 이어질 수 있다.

### 2\. 디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있다.

기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다. 추가하려는 디폴트 메서드가 기존 구현체들과 충돌하지는 않을지 심사숙고해야 함도 당연하다.  
반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는 데 아주 유용한 수단이며, 그 인터페이스를 더 쉽게 구현해 뢀용할 수 있게끔 해준다.  
디폴트 메서드는 인터페이스로부터 메서드를 제거하거나, 기존 메서드의 시그니처를 수정하는 용도가 아님을 명시하자.

## 결론

-   인터페이스를 설계할 때는 여전히 세심한 주의를 기울이자.
    -   새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거치자 (최소한 3가지는 구현해보기)
-   인터페이스를 릴리즈 한 후라도 결함을 수정하는게 가능한 경우도 있겠지만, 절대 그 가능성에 기대지 말자
